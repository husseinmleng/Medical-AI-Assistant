"""
LaTeX Medical Report Generation Agent
Generates professional medical reports in LaTeX format from conversation data.
"""

from typing import List, Dict, Any, Optional
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
from datetime import datetime
import re


def generate_latex_report(
    conversation: List[Dict[str, str]],
    patient_info: Dict[str, Any],
    analysis_results: Dict[str, Any],
    patient_name: str = "Patient Name Not Provided",
    report_title: str = "Medical Analysis Report"
) -> str:
    """
    Generates a professional LaTeX medical report from conversation and analysis data.
    
    Args:
        conversation: List of conversation messages with 'role' and 'content'
        patient_info: Dictionary containing patient questionnaire data
        analysis_results: Dictionary containing ML and X-ray analysis results
        patient_name: Name of the patient
        report_title: Title of the report
        
    Returns:
        Complete LaTeX document string ready for compilation
    """
    
    # Clean and format conversation content
    formatted_conversation = _format_conversation_for_latex(conversation)
    
    # Extract key findings from conversation using LLM
    key_findings = _extract_key_findings(conversation)
    
    # Format patient information
    patient_section = _format_patient_info(patient_info)
    
    # Format analysis results
    analysis_section = _format_analysis_results(analysis_results)
    
    # Generate recommendations
    recommendations = _generate_recommendations(conversation, analysis_results)
    
    # Current date
    current_date = datetime.now().strftime("%B %d, %Y")
    
    # Build the LaTeX document
    latex_content = f"""\\documentclass[11pt,a4paper]{{article}}
\\usepackage[utf8]{{inputenc}}
\\usepackage[T1]{{fontenc}}
\\usepackage{{geometry}}
\\usepackage{{fancyhdr}}
\\usepackage{{graphicx}}
\\usepackage{{xcolor}}
\\usepackage{{tcolorbox}}
\\usepackage{{enumitem}}
\\usepackage{{booktabs}}
\\usepackage{{longtable}}
\\usepackage{{amsmath}}
\\usepackage{{amssymb}}
\\usepackage{{hyperref}}
\\usepackage{{times}}

% Page setup
\\geometry{{margin=2.5cm}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[L]{{\\textbf{{{report_title}}}}}
\\fancyhead[R]{{\\today}}
\\fancyfoot[C]{{\\thepage}}

% Colors
\\definecolor{{headerblue}}{{RGB}}{{41, 128, 185}}
\\definecolor{{lightgray}}{{RGB}}{{248, 249, 250}}
\\definecolor{{darkgray}}{{RGB}}{{108, 117, 125}}

% Custom boxes
\\newtcolorbox{{infobox}}{{
    colback=lightgray,
    colframe=headerblue,
    boxrule=1pt,
    arc=3pt,
    left=10pt,
    right=10pt,
    top=10pt,
    bottom=10pt
}}

\\newtcolorbox{{warningbox}}{{
    colback=red!5,
    colframe=red!50,
    boxrule=1pt,
    arc=3pt,
    left=10pt,
    right=10pt,
    top=10pt,
    bottom=10pt
}}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
    \\centering
    \\vspace*{{2cm}}
    
    {{\\Huge \\textcolor{{headerblue}}{{\\textbf{{{report_title}}}}}}}
    
    \\vspace{{1.5cm}}
    
    {{\\Large Medical AI Assistant Analysis Report}}
    
    \\vspace{{2cm}}
    
    \\begin{{infobox}}
        \\centering
        \\textbf{{Patient Information}}
        
        \\vspace{{0.5cm}}
        
        \\textbf{{Name:}} {_escape_latex(patient_name)} \\\\
        \\textbf{{Report Date:}} {current_date} \\\\
        \\textbf{{Generated By:}} Medical AI Assistant
    \\end{{infobox}}
    
    \\vfill
    
    \\begin{{warningbox}}
        \\centering
        \\textbf{{IMPORTANT DISCLAIMER}}
        
        \\vspace{{0.3cm}}
        
        This report is generated by an AI assistant and is for informational purposes only. 
        It does not constitute medical diagnosis or treatment recommendations. 
        Always consult with a qualified healthcare professional for medical advice.
    \\end{{warningbox}}
    
\\end{{titlepage}}

\\newpage

% Table of Contents
\\tableofcontents
\\newpage

% Patient Information Section
\\section{{Patient Information}}

{patient_section}

% Analysis Results Section  
\\section{{Analysis Results}}

{analysis_section}

% Key Findings Section
\\section{{Key Clinical Findings}}

{key_findings}

% Conversation Summary Section
\\section{{Consultation Summary}}

The following section contains a summary of the patient consultation conducted with the Medical AI Assistant.

\\subsection{{Conversation Transcript}}

{formatted_conversation}

% Recommendations Section
\\section{{Recommendations}}

{recommendations}

% Footer Section
\\section{{Report Information}}

\\begin{{infobox}}
\\textbf{{Report Generation Details:}}
\\begin{{itemize}}[leftmargin=*]
    \\item Generated on: {current_date}
    \\item System: Medical AI Assistant v1.0
    \\item Language: Translated from Arabic to English
    \\item Report Type: Automated Analysis Report
\\end{{itemize}}
\\end{{infobox}}

\\vspace{{1cm}}

\\begin{{warningbox}}
\\textbf{{Medical Disclaimer:}} This automated report is based on patient responses and AI analysis. It is not a substitute for professional medical examination, diagnosis, or treatment. The patient should consult with qualified healthcare providers for proper medical evaluation and care decisions.
\\end{{warningbox}}

\\end{{document}}"""

    return latex_content


def _clean_text_for_latex(text: str) -> str:
    """
    Clean and validate text to prevent LaTeX compilation errors.
    This function handles common issues that cause LaTeX to fail.
    """
    if not text:
        return ""
    
    # Ensure text is a string
    try:
        if isinstance(text, bytes):
            text = text.decode('utf-8', errors='replace')
        text = str(text)
    except Exception:
        text = str(text)
    
    # Remove or replace problematic characters
    problematic_chars = {
        '\x00': '',      # Null bytes
        '\r': ' ',       # Carriage returns
        '\t': ' ',       # Tabs
        '\x0b': ' ',     # Vertical tab
        '\x0c': ' ',     # Form feed
        '\x1a': '',      # Substitute character
        '\x1b': '',      # Escape character
    }
    
    for char, replacement in problematic_chars.items():
        text = text.replace(char, replacement)
    
    # Remove any remaining control characters (except newlines)
    import re
    text = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]', '', text)
    
    # Ensure the text is valid UTF-8
    try:
        text.encode('utf-8')
    except UnicodeEncodeError:
        text = text.encode('utf-8', errors='replace').decode('utf-8')
    
    return text


def _escape_latex(text: str) -> str:
    """Escape special LaTeX characters in text."""
    if not text:
        return ""
    
    # First clean the text to remove problematic characters
    text = _clean_text_for_latex(text)
    
    # Dictionary of LaTeX special characters and their escaped versions
    latex_special_chars = {
        '&': '\\&',
        '%': '\\%', 
        '$': '\\$',
        '#': '\\#',
        '^': '\\textasciicircum{}',
        '_': '\\_',
        '{': '\\{',
        '}': '\\}',
        '~': '\\textasciitilde{}',
        '\\': '\\textbackslash{}'
    }
    
    result = text
    
    # First, handle backslashes to avoid double-escaping
    result = result.replace('\\', '\\textbackslash{}')
    
    # Then handle other special characters
    for char, escaped in latex_special_chars.items():
        if char != '\\':  # Skip backslash as we already handled it
            result = result.replace(char, escaped)
    
    # Clean up any problematic sequences that might cause LaTeX errors
    result = result.replace('\\textbackslash{}\\textbackslash{}', '\\textbackslash{}')
    result = result.replace('\\textbackslash{}\\textbackslash{}', '\\textbackslash{}')
    
    return result


def _format_conversation_for_latex(conversation: List[Dict[str, str]]) -> str:
    """Format conversation messages for LaTeX display."""
    if not conversation:
        return "No conversation data available."
    
    formatted_messages = []
    
    for i, msg in enumerate(conversation, 1):
        role = msg.get('role', 'unknown')
        content = msg.get('content', '')
        
        # Clean and escape content
        clean_content = _escape_latex(content)
        
        # Format based on role
        if role.lower() in ['user', 'patient']:
            formatted_messages.append(f"""
\\textbf{{Patient Message {i}:}}

\\begin{{quote}}
{clean_content}
\\end{{quote}}
""")
        elif role.lower() in ['assistant', 'ai', 'doctor']:
            formatted_messages.append(f"""
\\textbf{{AI Assistant Response {i}:}}

\\begin{{infobox}}
{clean_content}
\\end{{infobox}}
""")
    
    return "\n".join(formatted_messages)


def _format_patient_info(patient_info: Dict[str, Any]) -> str:
    """Format patient information section."""
    if not patient_info:
        return "No patient information available."
    
    info_lines = []
    
    # Define field mappings with user-friendly names
    field_mappings = {
        'patient_name': 'Patient Name',
        'age': 'Age',
        'breast_feeding_months': 'Breastfeeding Duration (months)',
        'family_history_breast_cancer': 'Family History of Breast Cancer',
        'recent_weight_loss': 'Recent Weight Loss',
        'previous_breast_conditions': 'Previous Breast Conditions',
        'symptom_duration_days': 'Symptom Duration (days)',
        'fatigue': 'Fatigue Symptoms'
    }
    
    info_lines.append("\\begin{longtable}{p{0.4\\textwidth}p{0.5\\textwidth}}")
    info_lines.append("\\toprule")
    info_lines.append("\\textbf{Information} & \\textbf{Value} \\\\")
    info_lines.append("\\midrule")
    
    for field, friendly_name in field_mappings.items():
        value = patient_info.get(field, 'Not provided')
        if value in ['yes', 'no']:
            value = value.capitalize()
        elif isinstance(value, (int, float)):
            value = str(value)
        
        escaped_value = _escape_latex(str(value))
        info_lines.append(f"{friendly_name} & {escaped_value} \\\\")
    
    info_lines.append("\\bottomrule")
    info_lines.append("\\end{longtable}")
    
    return "\n".join(info_lines)


def _format_analysis_results(analysis_results: Dict[str, Any]) -> str:
    """Format analysis results section."""
    sections = []
    
    # ML/Questionnaire Results
    ml_result = analysis_results.get('ml_result')
    ml_confidence = analysis_results.get('ml_confidence')
    
    if ml_result:
        sections.append("\\subsection{Questionnaire-Based Assessment}")
        
        if ml_result.lower() == 'positive':
            box_type = "warningbox"
        else:
            box_type = "infobox"
            
        confidence_text = f"{ml_confidence:.1f}\\%" if ml_confidence else "Not available"
        
        sections.append(f"""
\\begin{{{box_type}}}
\\textbf{{Assessment Result:}} {_escape_latex(ml_result)} \\\\
\\textbf{{Confidence Level:}} {confidence_text}
\\end{{{box_type}}}
""")
    
    # X-ray Results
    xray_result = analysis_results.get('xray_result')
    xray_confidence = analysis_results.get('xray_confidence')
    
    if xray_result:
        sections.append("\\subsection{X-ray Image Analysis}")
        
        if xray_result.lower() == 'positive':
            box_type = "warningbox"
        else:
            box_type = "infobox"
            
        xray_confidence_text = f"{xray_confidence:.1f}\\%" if xray_confidence else "Not available"
        
        sections.append(f"""
\\begin{{{box_type}}}
\\textbf{{X-ray Analysis Result:}} {_escape_latex(xray_result)} \\\\
\\textbf{{Confidence Level:}} {xray_confidence_text}
\\end{{{box_type}}}
""")
        
        # Add note about annotated image if available
        if analysis_results.get('annotated_image_path'):
            sections.append("""
\\textbf{Note:} An annotated X-ray image was generated during the analysis showing areas of interest identified by the AI system.
""")
    
    # Report Interpretation
    if analysis_results.get('interpretation_result'):
        sections.append("\\subsection{Medical Report Interpretation}")
        interpretation = _escape_latex(analysis_results['interpretation_result'])
        sections.append(f"""
\\begin{{infobox}}
{interpretation}
\\end{{infobox}}
""")
    
    return "\n".join(sections) if sections else "No analysis results available."


def _extract_key_findings(conversation: List[Dict[str, str]]) -> str:
    """Extract key clinical findings from conversation using LLM."""
    if not conversation:
        return "No conversation data available for analysis."
    
    try:
        # Prepare conversation text for analysis
        conversation_text = "\n".join([
            f"{msg['role']}: {msg['content']}" 
            for msg in conversation 
            if msg.get('content')
        ])
        
        prompt = f"""
Analyze the following medical consultation conversation and extract key clinical findings.
Focus on:
1. Symptoms mentioned by the patient
2. Risk factors identified
3. Concerns raised
4. Any notable observations
5. Assessment outcomes

Format your response as clear, professional medical findings suitable for a medical report.
Use bullet points and be concise but comprehensive.

Conversation:
{conversation_text}
"""
        
        llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.1, max_tokens=800)
        response = llm.invoke([HumanMessage(content=prompt)])
        
        # Clean and format the response
        findings = response.content.strip()
        return _escape_latex(findings)
        
    except Exception as e:
        print(f"Error extracting key findings: {e}")
        return "Unable to extract key findings from conversation."


def _generate_recommendations(
    conversation: List[Dict[str, str]], 
    analysis_results: Dict[str, Any]
) -> str:
    """Generate medical recommendations based on conversation and results."""
    try:
        # Prepare context for recommendation generation
        ml_result = analysis_results.get('ml_result', 'Not available')
        xray_result = analysis_results.get('xray_result', 'Not available')
        
        # Get last few assistant messages for context
        recent_advice = []
        for msg in reversed(conversation):
            if msg.get('role') in ['assistant', 'ai'] and len(recent_advice) < 3:
                recent_advice.append(msg.get('content', ''))
        
        context = "\n".join(recent_advice) if recent_advice else "No specific advice provided."
        
        prompt = f"""
Based on the following medical AI consultation results, generate professional medical recommendations:

Analysis Results:
- Questionnaire Assessment: {ml_result}
- X-ray Analysis: {xray_result}

AI Assistant's Advice:
{context}

Generate clear, professional recommendations that:
1. Summarize next steps for the patient
2. Emphasize the importance of professional medical consultation
3. Provide practical guidance for follow-up care
4. Include appropriate disclaimers

Format as a professional medical report recommendations section.
"""
        
        llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.2, max_tokens=600)
        response = llm.invoke([HumanMessage(content=prompt)])
        
        recommendations = response.content.strip()
        return _escape_latex(recommendations)
        
    except Exception as e:
        print(f"Error generating recommendations: {e}")
        return """
\\begin{infobox}
\\textbf{General Recommendations:}
\\begin{itemize}[leftmargin=*]
    \\item Consult with a qualified healthcare professional for proper medical evaluation
    \\item Follow up on any concerning symptoms or findings
    \\item Maintain regular health check-ups as recommended by your doctor
    \\item Keep records of all medical consultations and results
\\end{itemize}
\\end{infobox}
"""


def enhance_report_with_medical_context(latex_content: str) -> str:
    """Add additional medical context and formatting to the report."""
    # This function can be extended to add more sophisticated medical formatting
    # For now, it returns the content as-is
    return latex_content